<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LLM的定制管家--Ollama</title>
      <link href="/Project/buildRAGFlow/"/>
      <url>/Project/buildRAGFlow/</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><h3 id="一、Ollama是啥？——-一个让电脑变“AI脑”的神器"><a href="#一、Ollama是啥？——-一个让电脑变“AI脑”的神器" class="headerlink" title="一、Ollama是啥？—— 一个让电脑变“AI脑”的神器"></a><strong>一、Ollama是啥？—— 一个让电脑变“AI脑”的神器</strong></h3><ul><li><strong>人话版</strong>：Ollama就像大模型的“万能插座”，能让你在本地电脑上插拔各种AI模型（比如Llama、Qwen、DeepSeek），还不用写代码！</li><li><strong>官方定义</strong>：开源工具，支持一键下载、运行、管理大语言模型，兼容Windows&#x2F;Mac&#x2F;Linux，连你家路由器都能跑（只要内存够）！</li><li><strong>为啥用它</strong>：隐私安全（数据不出门）、省钱（不用买云服务）、装X利器（“看，我的电脑会写诗！”）</li></ul><h3 id="二、安装Ollama——比泡面还简单"><a href="#二、安装Ollama——比泡面还简单" class="headerlink" title="二、安装Ollama——比泡面还简单"></a><strong>二、安装Ollama——比泡面还简单</strong></h3><h4 id="Step-1：-下载安装包"><a href="#Step-1：-下载安装包" class="headerlink" title="Step 1： 下载安装包"></a><strong>Step 1：</strong> <strong>下载安装包</strong></h4><p><strong>官网直达</strong>：<a href="https://ollama.com/">Ollama</a>，点击“Download”按钮，选你的操作系统（Win&#x2F;Mac&#x2F;Linux三选一）</p><p><img src="https://bu.dusays.com/2025/05/19/682a0e98a958d.png" alt="ollama"></p><ul><li><p><strong>Windows用户</strong>：双击<code>.exe</code>文件，一路“Next”到底，连你家猫都能装（前提是它不乱踩键盘）</p></li><li><p><strong>Mac用户</strong>：拖进“应用程序”文件夹，比拉黑前男友微信还容易</p></li><li><p><strong>Linux用户</strong>：复制粘贴一行代码搞定👇：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://ollama.com/install.sh | sh  <span class="comment"># 连sudo都不需要，感动吗？</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Step-1：-验证安装"><a href="#Step-1：-验证安装" class="headerlink" title="Step 1： 验证安装"></a><strong>Step 1：</strong> <strong>验证安装</strong></h4><p>打开终端（Windows用PowerShell，Mac&#x2F;Linux用Terminal），输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama --version</span><br></pre></td></tr></table></figure><p>如果蹦出类似<code>ollama version 0.6.6</code>，恭喜！你已经打败了全国99%的安装失败选手</p><h3 id="三、下载模型——选个AI“灵魂伴侣”"><a href="#三、下载模型——选个AI“灵魂伴侣”" class="headerlink" title="三、下载模型——选个AI“灵魂伴侣”"></a><strong>三、下载模型——选个AI“灵魂伴侣”</strong></h3><h4 id="Step-1：挑模型就像选奶茶"><a href="#Step-1：挑模型就像选奶茶" class="headerlink" title="Step 1：挑模型就像选奶茶"></a><strong>Step 1：挑模型就像选奶茶</strong></h4><p><strong>官方模型库</strong>：<a href="Ollama/search">Ollama&#x2F;search</a>，大家可以选择如<code>deepseek-r1</code>、<code>qwen</code>、<code>Llama4</code>等热门模型进行下载。</p><p><img src="https://bu.dusays.com/2025/05/19/682a0e9984914.png" alt="ollama/search"></p><ul><li><strong>小内存用户</strong>（8GB）：选<code>qwen:7b</code>或<code>deepseek-r1:1.5b</code>（15亿参数，勉强能聊）。</li><li><strong>土豪配置</strong>（32GB+）：直接上<code>qwen:110b</code>或<code>deepseek-r1:70b</code>（参数越多越聪明，但别让电脑冒烟）</li></ul><h4 id="Step-2：一键下载模型"><a href="#Step-2：一键下载模型" class="headerlink" title="Step 2：一键下载模型"></a><strong>Step 2：一键下载模型</strong></h4><p>在终端输入魔法咒语：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run qwen:7b  <span class="comment"># 第一次运行会自动下载，泡杯咖啡等进度条吧～</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2025/05/19/682a0e9949903.png" alt="ollama-run"></p><p><strong>注意</strong>：模型默认存在<code>C:\Users\你的用户名\.ollama</code>（Windows）或<code>~/.ollama</code>（Mac&#x2F;Linux）。想换位置？且看第四步“高级操作”</p><h3 id="四、高级操作——让Ollama更“听话”"><a href="#四、高级操作——让Ollama更“听话”" class="headerlink" title="四、高级操作——让Ollama更“听话”"></a><strong>四、高级操作——让Ollama更“听话”</strong></h3><h4 id="1-改模型存储路径（救救C盘！）"><a href="#1-改模型存储路径（救救C盘！）" class="headerlink" title="1. 改模型存储路径（救救C盘！）"></a><strong>1. 改模型存储路径（救救C盘！）</strong></h4><ul><li><strong>Windows</strong>：<ol><li>右键“此电脑”→属性→高级系统设置→环境变量→新建系统变量<code>OLLAMA_MODELS</code>，路径填<code>D:\ollama</code>（随便你放哪）。</li><li>重启电脑，新模型都会存这里！</li></ol></li><li><strong>Mac&#x2F;Linux</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export OLLAMA_MODELS=/你的/自定义/路径&#x27;</span> &gt;&gt; ~/.zshrc  <span class="comment"># 或.bashrc</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc  <span class="comment"># 让配置生效</span></span><br></pre></td></tr></table></figure><h4 id="2-命令行装X指南"><a href="#2-命令行装X指南" class="headerlink" title="2. 命令行装X指南"></a><strong>2. 命令行装X指南</strong></h4><ul><li><code>ollama list</code>：看看你下载了哪些模型（显摆用）。</li></ul><p><img src="https://bu.dusays.com/2025/05/19/682a0e976a5d0.png" alt="ollama-list"></p><ul><li><p><code>ollama rm 模型名</code>：删掉不用的模型（清理前任的AI记忆）。</p></li><li><p><code>ollama run 模型名</code>：与喜欢的模型进行对话（我前面已经讲过了哦）。</p><ul><li>在对话页面输入 <code>/?</code>可以获取神龙之力，获取神的指引。</li></ul><p><img src="https://bu.dusays.com/2025/05/19/682a0e976a5d0.png" alt="ollama-help"></p><ul><li>可以输入 <code>/bye</code>以退出当前对话。</li></ul></li><li><p><code>ollama ps</code>：检查哪个模型在运行（防止AI偷偷写小说）。</p></li><li><p><code>ollama stop 模型名</code>：停止当前正在运行的模型（当然有个更暴力的方法直接杀掉对应的进程即可）。</p></li></ul><h3 id="五、图形界面——告别黑乎乎的终端！"><a href="#五、图形界面——告别黑乎乎的终端！" class="headerlink" title="五、图形界面——告别黑乎乎的终端！"></a><strong>五、图形界面——告别黑乎乎的终端！</strong></h3><h4 id="方案1：ChatBox（颜值党必备）"><a href="#方案1：ChatBox（颜值党必备）" class="headerlink" title="方案1：ChatBox（颜值党必备）"></a><strong>方案1：ChatBox（颜值党必备）</strong></h4><ol><li><strong>下载</strong>：<a href="https://chatboxai.app/">chatboxai.app</a>，安装后打开。</li><li><strong>设置</strong>：选“Ollama API”→填地址<code>http://localhost:11434</code>→选你下载的模型。</li><li><strong>开聊</strong>：现在界面和ChatGPT一模一样，截图发朋友圈吧！</li></ol><p><img src="https://bu.dusays.com/2025/05/19/682a0e976a5d0.png" alt="chatbox"></p><h4 id="方案2：Open-WebUI"><a href="#方案2：Open-WebUI" class="headerlink" title="方案2：Open WebUI"></a><strong>方案2：Open WebUI</strong></h4><ol><li><p><strong>安装Docker</strong>（Windows需先开WSL和Hyper-V）。</p></li><li><p>一行代码启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:8080 -v ollama-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure></li><li><p>访问<code>http://localhost:3000</code>，注册账号开聊</p></li></ol><h3 id="六、安全加固——别让电脑“裸奔”"><a href="#六、安全加固——别让电脑“裸奔”" class="headerlink" title="六、安全加固——别让电脑“裸奔”"></a><strong>六、安全加固——别让电脑“裸奔”</strong></h3><ul><li><strong>风险</strong>：默认端口<code>11434</code>暴露公网？黑客可能偷模型、挖矿甚至让你电脑唱《学猫叫》！</li><li><strong>防护措施</strong>：<ol><li><strong>本地使用</strong>：启动时加<code>OLLAMA_HOST=127.0.0.1 ollama serve</code>（锁死本地访问）。</li><li><strong>公网开放</strong>：用Nginx加密码认证+HTTPS加密（比较复杂，有缘下个教程再讲）。</li><li><strong>定期更新</strong>：<code>ollama update</code>！旧版本漏洞多到能筛米。</li></ol></li></ul><h3 id="七、常见问题——遇到bug别慌！"><a href="#七、常见问题——遇到bug别慌！" class="headerlink" title="七、常见问题——遇到bug别慌！"></a><strong>七、常见问题——遇到bug别慌！</strong></h3><ul><li><strong>Q：模型下载卡在99%？</strong><br>A：按<code>Ctrl+C</code>取消，重新运行命令，Ollama会自动续传（比断网重下小电影靠谱的多了）。</li><li><strong>Q：模型运行卡成PPT？</strong><br>A：换更小的模型（比如1.5B），或者检查内存是否被《原神》<code>吃光了</code>。</li><li><strong>Q：想用GPU加速？</strong><br>A：启动命令加<code>--gpu</code>，比如<code>ollama run qwen:7b --gpu</code>（前提是你有显卡且驱动正常）。</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目搭建 </tag>
            
            <tag> LLM </tag>
            
            <tag> Ollama </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo个人博客搭建及上线全流程</title>
      <link href="/Project/buildingHexoBlog/"/>
      <url>/Project/buildingHexoBlog/</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><h2 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h2><p><code>Hexo</code>是一个快速、简洁且高效的博客框架。 <code>Hexo</code> 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用现有的主题生成静态网页。</p><p>前置条件： 需要您的机器上安装好<code>Git</code>和<code>Node.js</code></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>注：前两步可以直接看官方文档：<a href="https://hexo.io/zh-cn/docs/">hexo安装部署</a></p><h5 id="1-hexo建站"><a href="#1-hexo建站" class="headerlink" title="1. hexo建站"></a>1. hexo建站</h5><ul><li><p>在终端执行以下命令来安装 Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></li><li><p>选择一个目录来存放你的博客文件，并在该目录下初始化 Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br><span class="line"><span class="built_in">cd</span> myblog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录下执行以下命令来生成静态文件并启动本地服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存文件</span></span><br><span class="line">hexo g <span class="comment"># 生成静态文件</span></span><br><span class="line">hexo s <span class="comment"># 启动本地服务器</span></span><br></pre></td></tr></table></figure></li></ul><p>​随后可以打开浏览器访问 <a href="http://localhost:4000/%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%9C%8B%E5%88%B0%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%AF%B4%E6%98%8E%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F%E3%80%82">http://localhost:4000/，如果看到博客页面，说明本地搭建成功。</a></p><ul><li><p>如果您觉得官方的主题不够美观，你可以从 <a href="https://hexo.io/themes/">Hexo 主题官网</a> 下载并安装你喜欢的主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-theme-name</span><br></pre></td></tr></table></figure><p>然后在 <code>_config.yml</code>文件中指定对应的主题即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">hexo-theme-name</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-hexo部署"><a href="#2-hexo部署" class="headerlink" title="2. hexo部署"></a>2. hexo部署</h5><ul><li><p><strong>创建 GitHub 仓库</strong>：登录 GitHub，新建一个仓库，名称为<code>git用户名.github.io</code>。</p></li><li><p><strong>配置部署信息</strong>：在 <code>_config.yml </code>文件中添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:git用户名/git用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure></li><li><p><strong>安装部署插件</strong>： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p><strong>执行部署命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d <span class="comment"># 清除缓存、生成静态文件并部署到 GitHub Pages</span></span><br></pre></td></tr></table></figure><p>完成后，你可以通过 <code>git用户名.github.io</code> 来访问你的博客</p></li></ul><h5 id="3-域名映射"><a href="#3-域名映射" class="headerlink" title="3. 域名映射"></a>3. 域名映射</h5><ul><li><p>购买域名：可以根据自己的喜好选择不同的渠道进去购买，因为阿里云比较省心，所以我比较喜欢用阿里云，下面是阿里云的购买链接：<a href="https://wanwang.aliyun.com/?spm=5176.100251.111252.24.375f4f158mTIrm">阿里云域名</a></p></li><li><p>DNS解析：登录到您的域名注册商控制台，找到域名管理并进入解析页面，添加一条记录，下面是我的配置参考：</p><p><img src="https://bu.dusays.com/2025/05/13/6822f92daf1b2.png" alt="阿里云DNS解析地址"></p></li><li><p>配置Hexo：在Hexo博客的<code>source</code>文件夹下创建一个名为<code>CNAME</code>的文件，内容为您的自定义域名:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com</span><br></pre></td></tr></table></figure></li><li><p>配置GitHub仓库：进入GitHub仓库的设置页面，在GitHub Pages部分找到Custom domain，输入您的自定义域名并保存:</p><p><img src="https://bu.dusays.com/2025/05/13/6822fc1e684fa.png" alt="git仓库配置"></p><p>完成以上步骤后，等待几分钟，Hexo博客就可以通过自定义域名访问了。</p></li></ul><h5 id="4-SSL证书购买与部署："><a href="#4-SSL证书购买与部署：" class="headerlink" title="4. SSL证书购买与部署："></a>4. SSL证书购买与部署：</h5><ul><li><p>证书购买：和域名一样，大家根据自己的喜好选择运营商购买SSL证书即可，阿里云地址为：<a href="https://yundun.console.aliyun.com/?spm=5176.12818093.overview_recent.3.3be92cc9Ci62yA&p=cas#/certExtend/buy/cn-hangzhou?currentPage=1&pageSize=10&keyword=&statusCode=">阿里云SSL证书管理</a></p><p><img src="https://bu.dusays.com/2025/05/13/6823012e23d31.png" alt="阿里云证书购买"></p><p>如果预算不够的话，也可以点击图片中的<code>个人测试证书</code>，可以免费购买3个月的</p></li><li><p>证书部署：</p><p>（1）创建证书：购买证书之后需要在证书管理页面创建证书</p><p><img src="https://bu.dusays.com/2025/05/13/6823023720c11.png" alt="创建证书"></p><p>（2）申请证书：创建完证书之后需要提交申请</p><p><img src="https://bu.dusays.com/2025/05/13/682304071e138.png" alt="申请证书"></p><p>证书申请通过之后证书的状态会变成已签发，此时证书申请完成。</p><p>（3）网站协议切换成Https：还是github仓库的设置界面，把Enforce HTTPS勾上即可</p><p><img src="https://bu.dusays.com/2025/05/13/6823099062a2f.png" alt="网站协议转换"></p></li></ul><p>至此，个人博客的搭建和部署结束，我们可以通过访问 <code>https://博客域名</code>访问我们的博客啦！</p><h3 id="网站验证"><a href="#网站验证" class="headerlink" title="网站验证"></a>网站验证</h3><p>当我们部署完我们的网站之后，我们虽然可以直接通过url访问我们的网站，但是我们无法通过搜索引擎检索到我们网站的相关内容，所以我们需要进行<code>网站验证</code>，网站验证主要就是为了让各大搜索引擎搜录我们的网站，这样可以让更多的人通过搜索引擎找到我们的网站。下面我将分享百度、谷歌、Bing三个常见搜索引擎的网站验证教程。</p><h5 id="1-百度"><a href="#1-百度" class="headerlink" title="1. 百度"></a>1. 百度</h5><p> (1): 首先我们需要访问<a href="https://ziyuan.baidu.com/">百度搜索资源平台</a>并进行登陆。</p><p> (2): 进入到用户中心的站点管理中，然后点击添加网站 </p><p><img src="https://bu.dusays.com/2025/05/13/68230dfcd574f.png" alt="添加网站"></p><p> (3): 在第三步：验证网站中，我们需要选择HTML标签验证，然后找到hexo项目中的head.pug文件一般路径为：.&#x2F;themes&#x2F;当前应用主题&#x2F;layout&#x2F;includes&#x2F;head.pug, <code>./</code>表示当前的hexo项目根目录，如果找不到在hexo项目中全局搜索即可。</p><p>找到之后我们在文件的最下面添加如下内容即可，谷歌和Bing也是相同的配置，后续不再赘述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 百度的html标记</span><br><span class="line">meta(name=&quot;baidu-site-verification&quot; content=&quot;codeva-vxWGXRA3Ih&quot;)</span><br></pre></td></tr></table></figure><p> (4): 由于百度网页爬虫抓取网站需要时间，因此我们可以手动把我们的网页手动提交到百度搜索引擎中进行搜录：</p><p><img src="https://bu.dusays.com/2025/05/13/682310f49659f.png" alt="网站搜录"></p><p>当我们成功提交之后，只需等待一些时间即可在搜索引擎中检索的我们网站中的相关内容。</p><h5 id="2-谷歌："><a href="#2-谷歌：" class="headerlink" title="2. 谷歌："></a>2. 谷歌：</h5><p> 访问<a href="https://search.google.com/search-console/welcome">Google Search Console</a>，使用<strong>Google账号</strong>登录后并选择第二个选项输入自己的网址即可</p><p><img src="https://bu.dusays.com/2025/05/13/682342d629ac9.png" alt="google search console"></p><p>作者这里因为输入的是https的网址验证直接通过了，如果大家还需要验证的话，选择验证方式为<code>HTML</code>标记，然后和百度的验证方式一致即可，在<code>head.pug</code>文件中添加google的html标记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 谷歌的html标记</span><br><span class="line">meta(name=&quot;google-site-verification&quot; content=&quot;填入相应码&quot;)</span><br></pre></td></tr></table></figure><p>最后进去google search console管理页面，可以看到需要有一天的时间准备数据：<br><img src="https://bu.dusays.com/2025/05/13/682347302b60a.png" alt="console"></p><h5 id="3-Bing"><a href="#3-Bing" class="headerlink" title="3. Bing"></a>3. Bing</h5><p>访问<a href="https://www.bing.com/webmasters/about?setlang=zh-cn">必应网站管理员工具</a>，随后点击开始使用<strong>Google账户</strong>仅进行登陆</p><p><img src="https://bu.dusays.com/2025/05/13/68234a080b939.png" alt="必应网站管理员工具"></p><p>然后选择添加网站时，我们可以选择从<code>Google Search Console</code>中导入，此时我们就可以便捷地把网站信息收录到Bing搜索引擎中了。</p><p>至此，关于Hexo个人博客搭建及上线全流程的内容已经全部结束了，希望我的以上内容可以给你一些帮助，如果你有疑问的话可以在评论区留言，或者给我发电子邮件，我看到后会及时解答，我们下个文章见😁。</p></div>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 项目搭建 </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中浮点数的进制转换原理</title>
      <link href="/Java/floatingPointNumberBaseConversion/"/>
      <url>/Java/floatingPointNumberBaseConversion/</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><h2 id="Java中浮点数的进制转换原理"><a href="#Java中浮点数的进制转换原理" class="headerlink" title="Java中浮点数的进制转换原理"></a>Java中浮点数的进制转换原理</h2><h3 id="有趣的现象："><a href="#有趣的现象：" class="headerlink" title="有趣的现象："></a>有趣的现象：</h3><p>在Java有一个非常有意思的现象，当我们定义一个浮点数，然后直接打印出来的时候，会发现打印出来的结果就是我们定义的值，但是如果这个浮点数参数了运算，我们打印运算后结果的时候，有时候输出的结果是存储再计算机中<strong>真实的值</strong>，但是有时后又不是，可以参考下面的例子，这是为什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(a); <span class="comment">// 0.1</span></span><br><span class="line">System.out.println(a + b); <span class="comment">// 0.30000000000000004</span></span><br><span class="line">System.out.println(a + c); <span class="comment">// 2.6</span></span><br></pre></td></tr></table></figure><h3 id="转换原理："><a href="#转换原理：" class="headerlink" title="转换原理："></a>转换原理：</h3><p>之所以会出现上面的这种情况，其实是java在把计算机中存储的二进制数据转换成十进制的时候，会把转换后结果的误差限定在**一个ULP(Unit in the Last Place)**的范围内，这样做的效果就是 <strong>可以使用最少的位数精确的表达出来浮点数的数值。</strong>下面是详细的介绍：</p><h5 id="1-Java打印浮点数的流程："><a href="#1-Java打印浮点数的流程：" class="headerlink" title="1. Java打印浮点数的流程："></a>1. Java打印浮点数的流程：</h5><p>众所周知，Java中想要使用print函数进行输出的话，需要把对应的数据类型先转换成String类型才可以，即使是八种基本数据类型也不例外。</p><ul><li>调用Double.toString()方法把浮点数转换成字符串类型<ul><li>继续调用FloatingDecimal.toJavaFormatString(d)方法进行类型的转换</li><li>在上面这个方法中会先调用getBinaryToASCIIConverter(d)方法先把二进制的转换成十进制的结果(在这个过程中会对转换后的十进制数据的精度进行限制)<ul><li>在getBinaryToASCIIConverter(d)方法中会进行参数的构造，然后调用 <strong>dtoa()<strong>方法把</strong>二进制</strong>浮点数转换成<strong>十进制</strong></li></ul></li><li>然后再调用toJavaFormatString()方法把十进制结果转换成字符串</li></ul></li><li>打印转换后的字符串结果</li></ul><h5 id="2-核心方法的源码："><a href="#2-核心方法的源码：" class="headerlink" title="2. 核心方法的源码："></a>2. 核心方法的源码：</h5><p>通过上面的流程其实不难发现，java之所以在打印的时候输出的浮点数精度不一样，全是**dtoa()**方法的功劳，下面是getBinaryToASCIIConverter(d) 和 dtoa( int binExp, long fractBits, int nSignificantBits, boolean isCompatibleFormat)的源码解读。</p><ul><li><p>getBinaryToASCIIConverter(d)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法其实就做了一件事，就是为dtoa方法构造参数：</span></span><br><span class="line"><span class="comment"> * 1. 首先把二进制浮点数据转换成长整型数据。之所以要进行转换是因为在计算机底层表示二进制的时候是使用阶码(二进制指数)，符号位以及尾数三个部分进行表示的，如果直接使用二进制浮点数进行后面的转换操作会比较麻烦，并且长整型和二进制浮点数都是64位的，这样可以方便地使用按位操作来提取这些部分，而不是直接进行浮点运算，所以这里转换成了长整型进行后面的操作。</span></span><br><span class="line"><span class="comment"> * 2. 计算出转换需要规格化后的的阶码，符号位，尾数，以及该数据类型的有效位：nSignificantBits</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> d：原始的double数据</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> isCompatibleFormat: 是否兼容特定格式(例如:IEEE 754)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">static</span> BinaryToASCIIConverter <span class="title function_">getBinaryToASCIIConverter</span><span class="params">(<span class="type">double</span> d, <span class="type">boolean</span> isCompatibleFormat)</span> &#123;</span><br><span class="line">    <span class="comment">// 把原始的64位二进制数据转换成64位长整型数据</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">dBits</span> <span class="operator">=</span> Double.doubleToRawLongBits(d);</span><br><span class="line">    <span class="comment">// 通过与符号位掩码 DoubleConsts.SIGN_BIT_MASK 进行按位与操作来判断 d 是否为负数。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isNegative</span> <span class="operator">=</span> (dBits&amp;DoubleConsts.SIGN_BIT_MASK) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 提取出尾数部分（有效位），通过与尾数位掩码 DoubleConsts.SIGNIF_BIT_MASK 进行按位与操作得到</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">fractBits</span> <span class="operator">=</span> dBits &amp; DoubleConsts.SIGNIF_BIT_MASK;</span><br><span class="line">    <span class="comment">// 提取出指数部分。首先用指数位掩码 DoubleConsts.EXP_BIT_MASK 提取出指数，然后右移 EXP_SHIFT 位，得到实际的指数值</span></span><br><span class="line">    <span class="type">int</span>  <span class="variable">binExp</span> <span class="operator">=</span> (<span class="type">int</span>)( (dBits&amp;DoubleConsts.EXP_BIT_MASK) &gt;&gt; EXP_SHIFT );</span><br><span class="line">    <span class="comment">// 检查是否为特殊值（NaN 或无穷大）。如果指数是最大值（表示无穷大或 NaN），且尾数为零，则返回正/负无穷大；否则，返回 NaN。</span></span><br><span class="line">    <span class="keyword">if</span> ( binExp == (<span class="type">int</span>)(DoubleConsts.EXP_BIT_MASK&gt;&gt;EXP_SHIFT) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( fractBits == <span class="number">0L</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> isNegative ? B2AC_NEGATIVE_INFINITY : B2AC_POSITIVE_INFINITY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> B2AC_NOT_A_NUMBER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>  nSignificantBits;</span><br><span class="line">    <span class="comment">// 1. 处理非规格化数字：如果指数为0（表示这是一个非规格化的数字），则需要将尾数左移，以便将其转为规格化形式，并调整指数。</span></span><br><span class="line">    <span class="keyword">if</span> ( binExp == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">// 如果指数为0并且位数也为0的情况，意味着这个浮点数就是0</span></span><br><span class="line">        <span class="keyword">if</span> ( fractBits == <span class="number">0L</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> isNegative ? B2AC_NEGATIVE_ZERO : B2AC_POSITIVE_ZERO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leadingZeros</span> <span class="operator">=</span> Long.numberOfLeadingZeros(fractBits);</span><br><span class="line">        <span class="type">int</span> <span class="variable">shift</span> <span class="operator">=</span> leadingZeros-(<span class="number">63</span>-EXP_SHIFT);</span><br><span class="line">        fractBits &lt;&lt;= shift;</span><br><span class="line">        binExp = <span class="number">1</span> - shift;</span><br><span class="line">        nSignificantBits =  <span class="number">64</span>-leadingZeros; <span class="comment">// recall binExp is  - shift count.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 处理规格化数字：如果指数非零，则将尾数与假设的最高有效位 FRACT_HOB 进行按位或操作，计算实际的有效位数 nSignificantBits。(这里其实是一个固定的标准，比如double类型的nSignificantBits固定位53位，float的为22位。</span></span><br><span class="line">        fractBits |= FRACT_HOB;</span><br><span class="line">        nSignificantBits = EXP_SHIFT+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 3. 调整指数偏移：从指数中减去偏移量 DoubleConsts.EXP_BIAS，得到实际的指数值。</span></span><br><span class="line">    binExp -= DoubleConsts.EXP_BIAS;</span><br><span class="line">    <span class="type">BinaryToASCIIBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> getBinaryToASCIIBuffer();</span><br><span class="line">    buf.setSign(isNegative);</span><br><span class="line">    <span class="comment">// 调用dtoa方法完成进制转换以及精度限制</span></span><br><span class="line">    buf.dtoa(binExp, fractBits, nSignificantBits, isCompatibleFormat);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>dtoa( int binExp, long fractBits, int nSignificantBits, boolean isCompatibleFormat)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这个方法的作用就是进行二进制与十进制的转换，并对结果进行精度的限制：</span></span><br><span class="line"><span class="comment">    * 1. 进行合法性校验，并计算得到一些转换时必要的参数，像：尾数的有效位，浮点数小数的位数等</span></span><br><span class="line"><span class="comment">    * 2. 判断当前的浮点数是否是简单的数，也就是判断精度大小以及是否是整数，如果是的话直接把二进制转换成十进制就可以了</span></span><br><span class="line"><span class="comment">    * 3. 如果是复杂的浮点数，需要计算得到B5，B2，S5，S2，M5，M2这六个参数，然后通过这六个参数对原来的二进制浮点数进行缩放和精度限制，以得到想要的结果。</span></span><br><span class="line"><span class="comment">    * 4. 对转换完成的结果进行四舍五入，确保最终的十进制表示尽可能精确地反映原始浮点数值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> binExp 浮点数的二进制指数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fractBits 浮点数的尾数部分</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nSignificantBits 该浮点类型的有效位</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> isCompatibleFormat 是否兼容特定的格式</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dtoa</span><span class="params">( <span class="type">int</span> binExp, <span class="type">long</span> fractBits, <span class="type">int</span> nSignificantBits, <span class="type">boolean</span> isCompatibleFormat)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 保证尾数大于0，小于等于0是没有意义的</span></span><br><span class="line">       <span class="keyword">assert</span> fractBits &gt; <span class="number">0</span> ;</span><br><span class="line">       <span class="comment">// 确保尾数的最高位为1，因为在上面的方法中，尾数已经被规范化了，这里如果为0的化明显是有错误的</span></span><br><span class="line">       <span class="keyword">assert</span> (fractBits &amp; FRACT_HOB)!=<span class="number">0</span>  ;</span><br><span class="line">       <span class="comment">// 计算fractBits末尾有多少个连续的零。</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tailZeros</span> <span class="operator">=</span> Long.numberOfTrailingZeros(fractBits);</span><br><span class="line">       <span class="comment">//  表示该浮点数真实有效的位数。这里 EXP_SHIFT + 1 是一个常量，表示浮点数有效位数的最大值(例如Double类型为53，去除掉尾数末尾连续的0之后的值就是nFractBits)</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">nFractBits</span> <span class="operator">=</span> EXP_SHIFT+<span class="number">1</span>-tailZeros;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 初始化两个标志位：decimalDigitsRoundedUp 表示是否需要进行四舍五入；exactDecimalConversion 表示是否精确转换（无精度损失）</span></span><br><span class="line">       decimalDigitsRoundedUp = <span class="literal">false</span>;</span><br><span class="line">       exactDecimalConversion = <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">// 计算小数部分的位数 nTinyBits，即有效位数减去指数部分之后的剩余位数，确保其非负。</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">nTinyBits</span> <span class="operator">=</span> Math.max( <span class="number">0</span>, nFractBits - binExp - <span class="number">1</span> );</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 处理“简单”的数，通过指数的大小判断当前的浮点数是否是极端的数据：指数在MIN_SMALL_BIN_EXP 到 MAX_SMALL_BIN_EXP 之间，表示数值的规模适中，这样的数不需要特别处理极大或极小的情况。它们的二进制浮点表示相对简单，转换成十进制字符串时可以用更高效、简单的方法处理，因此被认为是“容易处理”的数。如果指数 binExp 太小（小于MIN_SMALL_BIN_EXP），表示数值接近于零，可能会有大量前导零，在十进制转换中需要考虑非常小的数字。如果指数binExp 太大（大于 MAX_SMALL_BIN_EXP），表示数值非常大，需要处理大量尾随零和可能的溢出问题。</span></span><br><span class="line">       <span class="keyword">if</span> ( binExp &lt;= MAX_SMALL_BIN_EXP &amp;&amp; binExp &gt;= MIN_SMALL_BIN_EXP )&#123;</span><br><span class="line">  </span><br><span class="line">           <span class="comment">// 判断有效位的位数是否使用long类型可以存储以及是否会发生溢出(使用long类型比使用BigInteger类型计算的更快，所以在这判断了一下是否可以使用long进行加速计算)</span></span><br><span class="line">           <span class="keyword">if</span> ( (nTinyBits &lt; FDBigInteger.LONG_5_POW.length) &amp;&amp; ((nFractBits + N_5_BITS[nTinyBits]) &lt; <span class="number">64</span> ) )&#123;</span><br><span class="line">               <span class="comment">// 未规格化的尾数位数为0表示当前的数没有小数部分，直接使用整数部分的转换方法</span></span><br><span class="line">               <span class="keyword">if</span> ( nTinyBits == <span class="number">0</span> ) &#123;</span><br><span class="line">                   <span class="type">int</span> insignificant;</span><br><span class="line">                   <span class="keyword">if</span> ( binExp &gt; nSignificantBits )&#123;</span><br><span class="line">                       insignificant = insignificantDigitsForPow2(binExp-nSignificantBits-<span class="number">1</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       insignificant = <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 比较指数和有效位数的大小来使尾数左移或右移对应的尾数，这个操作非常的关键，经过移位后fractBits表示的就是浮点数的尾数了，而是二进制的整数</span></span><br><span class="line">                   <span class="keyword">if</span> ( binExp &gt;= EXP_SHIFT )&#123;</span><br><span class="line">                       fractBits &lt;&lt;= (binExp-EXP_SHIFT);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       fractBits &gt;&gt;&gt;= (EXP_SHIFT-binExp) ;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 调用 developLongDigits 方法将结果转换为十进制字符串表示</span></span><br><span class="line">                   developLongDigits( <span class="number">0</span>, fractBits, insignificant );</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 通过调用estimateDecExp()来获取当前浮点数的十进制指数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">decExp</span> <span class="operator">=</span> estimateDecExp(fractBits,binExp);</span><br><span class="line">       <span class="type">int</span> B2, B5;</span><br><span class="line">       <span class="type">int</span> S2, S5;</span><br><span class="line">       <span class="type">int</span> M2, M5;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 一个十进制可以表示为：x = m * 10^decEXp；进一步可以拆分为：x = m * 2^decExp * 5^decExp,这样就在十进制浮点数和二进制浮点数之间建立了联系(二进制：x = m * 2^binExp）</span></span><br><span class="line"><span class="comment">        * B5：它调整与 5 相关的因子，用来平衡十进制指数的影响，取0和-decExp中的最大值，当decExp &lt; 0时，表示十进制指数是负的，意味着需要将数值缩小到一个更小的范围。因此，我们需要乘以5^B5来抵消负指数的影响</span></span><br><span class="line"><span class="comment">        * B2：B2是一个非负整数，它调整与 2 相关的因子，用来平衡二进制指数的影响，表示在转换过程中，需要乘以 2^B2 以平衡二进制指数的2的部分。</span></span><br><span class="line"><span class="comment">        * S5：它调整与 5 相关的因子，也是用来平衡十进制指数的影响的，取0和decExp中的最大值，当decExp &gt; 0时，表示十进制指数时正的，意味着转换后会将数值放大到一个更大的范围。因此，需要除以5^S5来抵消正指数的影响</span></span><br><span class="line"><span class="comment">        * S2：B2是一个非负整数，它调整与 2 相关的因子，用来平衡二进制指数的影响，表示在转换过程中，需要除以 2^B2 以平衡二进制指数的2的部分。</span></span><br><span class="line"><span class="comment">        * 从上面的定义中不难看出，B 系列负责放大数值，以便将二进制数转换为一个可操作的整数范围。S 系列负责缩小数值，以确保最终结果与十进制表示相符。例如：在将一个二进制浮点数表示成形如 M * 10^E 的十进制形式时：我们需要放大数值 M，使其成为一个适合处理的整数范围，这个放大的操作由 B5 和 B2 来完成。同时，必须确保十进制指数 E 被正确调整。这意味着，我们在放大 M 的时候，还需要相应地缩小与指数相关的部分，这个缩小操作由 S5 和 S2 来完成。</span></span><br><span class="line"><span class="comment">        * 最终的公式：M&#x27; = (M * 2^B2 * 5^B5) / (2^S2 * 5^S5)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       B5 = Math.max( <span class="number">0</span>, -decExp );</span><br><span class="line">       B2 = B5 + nTinyBits + binExp;</span><br><span class="line">       S5 = Math.max( <span class="number">0</span>, decExp );</span><br><span class="line">       S2 = S5 + nTinyBits;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * M: (1 / 2^nSignificantBits) * 2^nTinyBits * 10^max(0, -decExp), 此时M表示的是 “当前浮点数”的最小浮动单位ULP的一半，这样我们就可以根据M的值来确定转换后的十进制结果的精度了</span></span><br><span class="line"><span class="comment">        * M5：M 的十进制部分(5 的因子)。它表示需要乘以多少个 5 来缩放最小单位 M。M5 被设置为 B5，这意味着在十进制因子方面，M 与 B 有相同的 5 因子。因为我们需要确保在十进制的缩放上，它们是同步的。</span></span><br><span class="line"><span class="comment">        * M2：M 的二进制部分(2 的因子)。它表示需要乘以多少个 2 来缩放最小单位 M。M2 被设定为 B2 - nSignificantBits，这是因为 M 代表了 ULP 的一半。减去 nSignificantBits 后，M 的二进制缩放与 B 对齐，同时反映出 M 的实际二进制精度需求。</span></span><br><span class="line"><span class="comment">        * M系列参数的作用：在十进制转换过程中，我们需要确定要生成多少位数（即确定如何四舍五入）。M 的值用来界定舍入的边界。当我们对十进制数进行迭代计算时，如果余数小于等于 M，那么可以认为当前的十进制结果已经足够准确，不需要再继续计算。例如，当我们得到一个结果 B/S，如果余数（B % S）比 M 更小，则表示这个结果是精确的（在浮点精度范围内），不需要再进一步增加精度。</span></span><br><span class="line"><span class="comment">        * ULP(Unit in the Last Place)：指的是浮点数表示中的最小可分辨单位，每一个浮点数都有一个固定的精度，这种情况下ULP就是该浮点数尾数的最小的变化，如浮点数为0.1，那么下一个可以表示的浮点数就是0.2，此时ULP是这两个浮点数的差异(0.1，0.2)。所以ULP通常用于量化浮点数运算中的误差范围，并确保计算精度。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       M5 = B5;</span><br><span class="line">       M2 = B2 - nSignificantBits;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 去掉尾数末尾的0</span></span><br><span class="line">       fractBits &gt;&gt;&gt;= tailZeros;</span><br><span class="line">       <span class="comment">// 作用是调整二进制指数 B2，使得尾数fractBits的最高有效位（最左侧的非零位）与预期的位置对齐。调整 B2 的目的是为了确保在二进制到十进制转换的过程中，计算能够尽可能准确地表示浮点数，减少舍入误差。这种调整使得转换算法能够有效地操作不同表示形式的数值，从而实现高效且精确的计算。</span></span><br><span class="line">       B2 -= nFractBits-<span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 找到B2，S2，M2中的公共因子，把公共因子去掉，这里是方便计算用的</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">common2factor</span> <span class="operator">=</span> Math.min( B2, S2 );</span><br><span class="line">       B2 -= common2factor;</span><br><span class="line">       S2 -= common2factor;</span><br><span class="line">       M2 -= common2factor;</span><br><span class="line">       <span class="comment">// 当尾数只有一位的时候需要让M2的值更小一些，以便能更精确的表示最小化范围的浮点数</span></span><br><span class="line">       <span class="keyword">if</span> ( nFractBits == <span class="number">1</span> ) &#123;</span><br><span class="line">           M2 -= <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果M2 = 0表示当前的浮点数精度的上下界已经不能再缩小了，M2 &lt; 0其实是无效的，但实际上又需要进行缩小，所以让B2，S2也缩小相应的值来进行平衡</span></span><br><span class="line">       <span class="keyword">if</span> ( M2 &lt; <span class="number">0</span> )&#123;</span><br><span class="line">           B2 -= M2;</span><br><span class="line">           S2 -= M2;</span><br><span class="line">           M2 =  <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 转换后十进制的位数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">ndigit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 精度的上下界</span></span><br><span class="line">       <span class="type">boolean</span> low, high;</span><br><span class="line">       <span class="comment">// 用于判断小数点前最后一位的精确度差异</span></span><br><span class="line">       <span class="type">long</span> lowDigitDifference;</span><br><span class="line">       <span class="comment">// 当前十进制位的具体值</span></span><br><span class="line">       <span class="type">int</span>  q;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// Bbits 是在二进制转换过程中，表示十进制数的二进制位数总数的近似值。这个值包含了尾数的有效位数、乘以 2 的调整以及乘以 5 的调整。通过计算 Bbits，我们可以估算尾数 B 在乘以 5^B5 和 2^B2 后所需的总二进制位数。</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">Bbits</span> <span class="operator">=</span> nFractBits + B2 + (( B5 &lt; N_5_BITS.length )? N_5_BITS[B5] : ( B5*<span class="number">3</span> ));</span><br><span class="line">       <span class="comment">// 乘以10后的有效位数, 程序可以决定使用不同的优化路径来转换浮点数，例如使用整数或长整数运算。</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">tenSbits</span> <span class="operator">=</span> S2+ <span class="number">1</span> + (( (S5+<span class="number">1</span>) &lt; N_5_BITS.length )? N_5_BITS[(S5+<span class="number">1</span>)] : ( (S5+<span class="number">1</span>)*<span class="number">3</span> ));</span><br><span class="line">       <span class="comment">// 根据Bbits以及tenSbits的值来确定使用什么长度的数据类型来转换浮点数，这个方法中，32位/64位/FDBigInteger这三个不同的数据类型的处理逻辑是一样的</span></span><br><span class="line">       <span class="keyword">if</span> ( Bbits &lt; <span class="number">64</span> &amp;&amp; tenSbits &lt; <span class="number">64</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> ( Bbits &lt; <span class="number">32</span> &amp;&amp; tenSbits &lt; <span class="number">32</span>)&#123;</span><br><span class="line">               <span class="comment">// 计算当前的尾数 fractBits 乘以 5 的 B5 次方，再乘以 2 的 B2 次方。这表示尾数部分的十进制值的起始点</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ((<span class="type">int</span>)fractBits * FDBigInteger.SMALL_5_POW[B5] ) &lt;&lt; B2;</span><br><span class="line">               <span class="comment">// 基数部分，乘以 5 的 S5 次方和 2 的 S2 次方</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> FDBigInteger.SMALL_5_POW[S5] &lt;&lt; S2;</span><br><span class="line">               <span class="comment">// 上下界的差值（用来确定精度范围），乘以 5 的 M5 次方和 2 的 M2 次方。</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> FDBigInteger.SMALL_5_POW[M5] &lt;&lt; M2;</span><br><span class="line">               <span class="comment">// s 乘以 10，用来确定下一位的十进制值。</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">tens</span> <span class="operator">=</span> s * <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">               ndigit = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">// 计算尾数除以基数的商，结果就是当前位的十进制的值</span></span><br><span class="line">               q = b / s;</span><br><span class="line">               <span class="comment">// 将尾数的余数乘以 10，准备计算下一位</span></span><br><span class="line">               b = <span class="number">10</span> * ( b % s );</span><br><span class="line">               <span class="comment">// 将上下界乘以 10，以确保计算精度, 并更新上下界的值</span></span><br><span class="line">               m *= <span class="number">10</span>;</span><br><span class="line">               low  = (b &lt;  m );</span><br><span class="line">               high = (b+m &gt; tens );</span><br><span class="line">               <span class="keyword">assert</span> q &lt; <span class="number">10</span> : q;</span><br><span class="line">               <span class="comment">// 如果第一次计算的商 q 为 0，且不超出范围（!high），则表示估计的指数 decExp 过高，需要减小。</span></span><br><span class="line">               <span class="keyword">if</span> ( (q == <span class="number">0</span>) &amp;&amp; ! high )&#123;</span><br><span class="line">                   decExp--;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 将计算的数字字符添加到结果数组中。</span></span><br><span class="line">                   digits[ndigit++] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + q);</span><br><span class="line">               &#125;</span><br><span class="line">  </span><br><span class="line">               <span class="comment">// 判断当前的格式是否与预期的输出格式兼容/指数是否太大或者太小</span></span><br><span class="line">               <span class="keyword">if</span> ( !isCompatibleFormat ||decExp &lt; -<span class="number">3</span> || decExp &gt;= <span class="number">8</span> )&#123;</span><br><span class="line">                   high = low = <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 通过迭代来转换并保存十进制的每一位</span></span><br><span class="line">               <span class="keyword">while</span>( ! low &amp;&amp; ! high )&#123;</span><br><span class="line">                   q = b / s;</span><br><span class="line">                   b = <span class="number">10</span> * ( b % s );</span><br><span class="line">                   m *= <span class="number">10</span>;</span><br><span class="line">                   <span class="keyword">assert</span> q &lt; <span class="number">10</span> : q;</span><br><span class="line">                   <span class="keyword">if</span> ( m &gt; <span class="number">0L</span> )&#123;</span><br><span class="line">                       low  = (b &lt;  m );</span><br><span class="line">                       high = (b+m &gt; tens );</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       low = <span class="literal">true</span>;</span><br><span class="line">                       high = <span class="literal">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   digits[ndigit++] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + q);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 用于判断小数点前最后一位的精确度差异</span></span><br><span class="line">               lowDigitDifference = (b&lt;&lt;<span class="number">1</span>) - tens;</span><br><span class="line">               <span class="comment">// 表示是否已经精确转换为十进制表示（b == 0 表示尾数已经全部转换完成）</span></span><br><span class="line">               exactDecimalConversion  = (b == <span class="number">0</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> (fractBits * FDBigInteger.LONG_5_POW[B5] ) &lt;&lt; B2;</span><br><span class="line">               <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> FDBigInteger.LONG_5_POW[S5] &lt;&lt; S2;</span><br><span class="line">               <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> FDBigInteger.LONG_5_POW[M5] &lt;&lt; M2;</span><br><span class="line">               <span class="type">long</span> <span class="variable">tens</span> <span class="operator">=</span> s * <span class="number">10L</span>;</span><br><span class="line">  </span><br><span class="line">               ndigit = <span class="number">0</span>;</span><br><span class="line">               q = (<span class="type">int</span>) ( b / s );</span><br><span class="line">               b = <span class="number">10L</span> * ( b % s );</span><br><span class="line">               m *= <span class="number">10L</span>;</span><br><span class="line">               low  = (b &lt;  m );</span><br><span class="line">               high = (b+m &gt; tens );</span><br><span class="line">               <span class="keyword">assert</span> q &lt; <span class="number">10</span> : q;</span><br><span class="line">               <span class="keyword">if</span> ( (q == <span class="number">0</span>) &amp;&amp; ! high )&#123;</span><br><span class="line">                   decExp--;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   digits[ndigit++] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + q);</span><br><span class="line">               &#125;</span><br><span class="line">  </span><br><span class="line">               <span class="keyword">if</span> ( !isCompatibleFormat || decExp &lt; -<span class="number">3</span> || decExp &gt;= <span class="number">8</span> )&#123;</span><br><span class="line">                   high = low = <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">while</span>( ! low &amp;&amp; ! high )&#123;</span><br><span class="line">                   q = (<span class="type">int</span>) ( b / s );</span><br><span class="line">                   b = <span class="number">10</span> * ( b % s );</span><br><span class="line">                   m *= <span class="number">10</span>;</span><br><span class="line">                   <span class="keyword">assert</span> q &lt; <span class="number">10</span> : q;</span><br><span class="line">                   <span class="keyword">if</span> ( m &gt; <span class="number">0L</span> )&#123;</span><br><span class="line">                       low  = (b &lt;  m );</span><br><span class="line">                       high = (b+m &gt; tens );</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       low = <span class="literal">true</span>;</span><br><span class="line">                       high = <span class="literal">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   digits[ndigit++] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + q);</span><br><span class="line">               &#125;</span><br><span class="line">               lowDigitDifference = (b&lt;&lt;<span class="number">1</span>) - tens;</span><br><span class="line">               exactDecimalConversion  = (b == <span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  </span><br><span class="line">           <span class="type">FDBigInteger</span> <span class="variable">Sval</span> <span class="operator">=</span> FDBigInteger.valueOfPow52(S5, S2);</span><br><span class="line">           <span class="type">int</span> <span class="variable">shiftBias</span> <span class="operator">=</span> Sval.getNormalizationBias();</span><br><span class="line">           Sval = Sval.leftShift(shiftBias); <span class="comment">// normalize so that division works better</span></span><br><span class="line">  </span><br><span class="line">           <span class="type">FDBigInteger</span> <span class="variable">Bval</span> <span class="operator">=</span> FDBigInteger.valueOfMulPow52(fractBits, B5, B2 + shiftBias);</span><br><span class="line">           <span class="type">FDBigInteger</span> <span class="variable">Mval</span> <span class="operator">=</span> FDBigInteger.valueOfPow52(M5 + <span class="number">1</span>, M2 + shiftBias + <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">           <span class="type">FDBigInteger</span> <span class="variable">tenSval</span> <span class="operator">=</span> FDBigInteger.valueOfPow52(S5 + <span class="number">1</span>, S2 + shiftBias + <span class="number">1</span>); <span class="comment">//Sval.mult( 10 );</span></span><br><span class="line">  </span><br><span class="line">           ndigit = <span class="number">0</span>;</span><br><span class="line">           q = Bval.quoRemIteration( Sval );</span><br><span class="line">           low  = (Bval.cmp( Mval ) &lt; <span class="number">0</span>);</span><br><span class="line">           high = tenSval.addAndCmp(Bval,Mval)&lt;=<span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">           <span class="keyword">assert</span> q &lt; <span class="number">10</span> : q;</span><br><span class="line">           <span class="keyword">if</span> ( (q == <span class="number">0</span>) &amp;&amp; ! high )&#123;</span><br><span class="line">               decExp--;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               digits[ndigit++] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + q);</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           <span class="keyword">if</span> (!isCompatibleFormat || decExp &lt; -<span class="number">3</span> || decExp &gt;= <span class="number">8</span> )&#123;</span><br><span class="line">               high = low = <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span>( ! low &amp;&amp; ! high )&#123;</span><br><span class="line">               q = Bval.quoRemIteration( Sval );</span><br><span class="line">               <span class="keyword">assert</span> q &lt; <span class="number">10</span> : q;</span><br><span class="line">               Mval = Mval.multBy10();</span><br><span class="line">               low  = (Bval.cmp( Mval ) &lt; <span class="number">0</span>);</span><br><span class="line">               high = tenSval.addAndCmp(Bval,Mval)&lt;=<span class="number">0</span>;</span><br><span class="line">               digits[ndigit++] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + q);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> ( high &amp;&amp; low )&#123;</span><br><span class="line">               Bval = Bval.leftShift(<span class="number">1</span>);</span><br><span class="line">               lowDigitDifference = Bval.cmp(tenSval);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               lowDigitDifference = <span class="number">0L</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           exactDecimalConversion  = (Bval.cmp( FDBigInteger.ZERO ) == <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 十进制指数+1，在格式化过程中，指数部分的偏移量需要调整。</span></span><br><span class="line">       <span class="built_in">this</span>.decExponent = decExp+<span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 十进制数字数组 digits 中第一个有效数字的索引。</span></span><br><span class="line">       <span class="built_in">this</span>.firstDigitIndex = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// nDigits 是有效的数字总数，即转换后得到的十进制数字的位数。</span></span><br><span class="line">       <span class="built_in">this</span>.nDigits = ndigit;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 在浮点数转换过程中，直接使用计算得到的结果可能会导致精度问题。特别是在我们尝试将尾数的二进制部分精确地转换为十进制时，可能会出现以下两种情况：</span></span><br><span class="line"><span class="comment">        *  低估（b &lt; m）：当前的结果 b 在舍入时可能偏低，意味着我们需要增加最后的数字，以接近真实值。</span></span><br><span class="line"><span class="comment">        *  高估（b + m &gt; tens）：当前的结果 b 加上舍入值 m 超过了基准值 tens，这表明当前结果 b 可能高于真实值，我们需要增加最后的数字来修正偏差。</span></span><br><span class="line"><span class="comment">        * 所以：舍入操作是为了在浮点数转换为十进制数时，处理精度和表示问题。通过在 b &lt; m 或 b + m &gt; tens 时进行舍入，可以确保最终的十进制表示尽可能精确地反映原始浮点数值。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> ( high )&#123;</span><br><span class="line">           <span class="keyword">if</span> ( low )&#123;</span><br><span class="line">               <span class="keyword">if</span> ( lowDigitDifference == <span class="number">0L</span> )&#123;</span><br><span class="line">                   <span class="keyword">if</span> ( (digits[firstDigitIndex+nDigits-<span class="number">1</span>]&amp;<span class="number">1</span>) != <span class="number">0</span> ) &#123;</span><br><span class="line">                       roundup();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( lowDigitDifference &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                   roundup();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               roundup();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-具体的例子："><a href="#3-具体的例子：" class="headerlink" title="3. 具体的例子："></a>3. 具体的例子：</h5><p>假如，打印<code>0.1</code> + <code>0.2</code>的值</p><ul><li><p>Java 在执行浮点数运算（如 <code>0.1 + 0.2</code>）时，会先将十进制的浮点数 <code>0.1</code> 和 <code>0.2</code> 转换为符合 IEEE 754 标准的二进制浮点数表示。由于 <code>0.1</code> 和 <code>0.2</code> 不能精确地用二进制表示，因此在这个转换过程中会产生一些精度舍入误差。转换后的二进制数被输入到 CPU 的 ALU进行加法操作。在这一过程中，也可能会因为运算的有限精度再次引入微小的舍入误差，得到一个近似的二进制结果。</p></li><li><p>Java 拿到这个二进制浮点数结果后，会调用 <code>Double.toString()</code> 方法来生成结果的十进制字符串表示。<code>Double.toString()</code> 方法内部使用了 <code>dtoa()</code> 算法，该算法将二进制浮点数转换回十进制，同时根据当前的 <code>M</code> 值（决定输出的有效位数）进行精度舍入。</p></li><li><p>dtoa执行逻辑：</p><ul><li><p>输入参数：</p><ul><li><code>binExp = -2</code>：二进制指数</li><li><code>fractBits = 5404319552844596</code>：64位的长整型尾数。</li><li><code>nSignificantBits = 53</code>：有效位的位数。</li><li><code>isCompatibleFormat = true</code>：是否与 Java 的浮点格式兼容。</li></ul></li><li><p>计算相关参数：</p><ul><li><code>tailZeros = 2</code>：尾数部分的末尾有两个0</li><li><code>nFractBits = 51</code>：尾数部分减去末尾0后的实际的有效位</li><li><code>nTinyBits = 52</code>：二进制浮点数小数的位数</li></ul></li><li><p>判断当前的浮点数是否时<code>简单数</code>，简单数就是大小适中(没有极端值)并且没有小数部分的浮点数，这种浮点数直接移位对齐然后转换成对应的十进制就可以了，很明显这里不是简单数</p></li><li><p>如果当前的浮点数是<code>复杂数</code>，那么就需要先求出对应的六个参数：</p><ul><li><code>B5 = 1</code></li><li><code>B2 = 51</code></li><li><code>S5 = 0</code></li><li><code>S2 = 52</code></li><li><code>M5 = 1</code></li><li><code>M2 = -2</code></li><li>尾数部分右移去除末尾的<code>0</code>，同时<code>B2</code>,<code>S2</code>,<code>M2</code>去除掉公共的指数<ul><li><code>fractBits = 1351079888211149</code></li><li><code>B2 = 0</code></li><li><code>S2 = 51</code></li><li><code>M2 = -3</code>：由于<code>M2 &lt; 0</code>，所以需要把<code>M2</code>置为0，同时<code>B2</code>和<code>S2</code>加上对应的值，所以最终的结果为<code>B2 = 3</code>, <code>S2 = 54</code>,<code>M2 = 0</code></li></ul></li></ul></li><li><p>然后就是具体的计算了，因为当前的类型是double，所以使用的是64位的long来保存中间结果，各中间结果的具体数值如下(可以根据上面源码中的公式计算得出)：</p><ul><li><code>b = 54043195528445960</code></li><li><code>s = 18014398509481984</code></li><li><code>m = 5</code></li><li><code>tens = 180143985094819840</code></li><li><code>q = 3</code></li><li><code>更新后的b = 80</code></li><li><code>low = false</code></li><li><code>high = false</code></li></ul><p>通过判断是否超出精度来决定是否保存的前的结果到digits结果数组中</p></li><li><p>通过执行下面的代码进行不断的迭代最终得到：<code>digits: [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,,,]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( ! low &amp;&amp; ! high )&#123;</span><br><span class="line">    q = (<span class="type">int</span>) ( b / s );</span><br><span class="line">    b = <span class="number">10</span> * ( b % s );</span><br><span class="line">    m *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">assert</span> q &lt; <span class="number">10</span> : q; </span><br><span class="line">    <span class="keyword">if</span> ( m &gt; <span class="number">0L</span> )&#123;</span><br><span class="line">        low  = (b &lt;  m );</span><br><span class="line">        high = (b+m &gt; tens );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        low = <span class="literal">true</span>;</span><br><span class="line">        high = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    digits[ndigit++] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据<code>low</code>和<code>high</code>的值判断一下是否需要进行舍入以提高精度，在这个例子中不需要进行舍入操作</p></li><li><p>最后就是把转换后的保存了十进制的<code>digits</code>数据转换成String类型进行输出</p></li></ul></li></ul><h5 id="4-原理总结："><a href="#4-原理总结：" class="headerlink" title="4. 原理总结："></a>4. 原理总结：</h5><p>（1）<strong>Java 中浮点数进制转换的过程和机制：</strong>Java 使用 IEEE 754 双精度浮点数格式（<code>double</code>）来表示浮点数，这种格式将一个浮点数表示为符号位、指数部分和尾数部分的组合。由于十进制小数（如 <code>0.1</code> 或 <code>0.2</code>）无法精确地用二进制表示，所以浮点数的二进制表示通常是一个近似值。这种表示导致在浮点数的计算和转换过程中出现舍入误差。在 Java 中，将浮点数转换为十进制表示是通过 <code>dtoa</code> 方法（double to ASCII）来实现的。在这个方法中，<code>M</code> 的计算决定了输出结果的精度和舍入行为。</p><p>M在 <code>dtoa</code> 方法中的作用：<code>M</code> 的计算和使用决定了浮点数在转换为十进制字符串时的精度和舍入方向，直接影响到最终的输出结果。</p><ul><li>如果 <code>M</code> 较大，表示浮点数的两个相邻值之间有较大的差距，<code>dtoa</code> 方法会选择较少的有效位数来表示数值，从而输出一个更简洁的十进制数。</li><li>果 <code>M</code> 较小，则表示浮点数的相邻值之间的差距很小，<code>dtoa</code> 方法会保留更多的有效位数来确保精度。</li></ul><p>（2）<strong>Java 中浮点数赋值、舍入及运算输出差异的机制</strong></p><ul><li>直接赋值：<ul><li>当浮点数被直接赋值时，Java 将十进制数转换为最接近的 IEEE 754 二进制浮点数表示。转换后的结果是一个近似值。</li><li>输出时，Java 使用 <code>dtoa</code> 方法，将这个二进制表示转回十进制字符串，其中 <code>M</code> 决定了输出的舍入方式和精度。因此，可能会输出一个用户期望的简短结果（如 <code>0.1</code>），而不是精确的二进制表示值。</li></ul></li><li>舍入后的值：<ul><li>当调用round()函数对浮点数进行舍入的时候(BigDecimal的setScale方法为例，这个方法可以在进行精度的舍入的时候保留指定的精度并且可以指定舍入的方向)，首先会根据相关算法进行舍入，然后把十进制的结果换为最接近的二进制浮点数表示。</li><li>输出时还是会调用<code>dtoa</code> 方法，将这个二进制表示转回十进制字符串，输出的舍入方式和精度依旧由M决定。</li></ul></li><li>运算的值：<ul><li>浮点数在运算时（如 <code>0.1 + 0.2</code>），每一步计算都会引入微小的舍入误差，这是因为所有运算都基于浮点数的二进制近似表示。</li><li>运算结果的输出也是通过 <code>dtoa</code> 方法自动格式化的。<code>M</code> 的值决定了输出的有效位数和舍入行为，因此可能会出现 <code>0.30000000000000004</code> 而不是 <code>0.3</code> 的结果。</li></ul></li></ul><p>总之：在 Java 中，浮点数赋值、舍入和运算的输出差异主要源于二进制浮点数转换为十进制数进行输出的时候，在 <code>dtoa</code> 方法中会根据<code>M</code>的值处理精度和舍入问题，<code>M</code>的值由想要输出的浮点数的内容决定，所以<strong>浮点数本身的精度是决定输出精度的关键而不是操作的类型</strong>(这里的精度指的是浮点数在java中的精度，比如0.1的精度就是小数点后一位)。</p></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> 底层 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浮点数的精度问题</title>
      <link href="/Basic/floatingPointPrecision/"/>
      <url>/Basic/floatingPointPrecision/</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><h2 id="浮点数精度问题"><a href="#浮点数精度问题" class="headerlink" title="浮点数精度问题"></a>浮点数精度问题</h2><h3 id="1-两个浮点数是否可以直接比较大小？"><a href="#1-两个浮点数是否可以直接比较大小？" class="headerlink" title="1. 两个浮点数是否可以直接比较大小？"></a>1. 两个浮点数是否可以直接比较大小？</h3><ul><li><p><strong>直接比较的可行性</strong></p><p><strong>大小比较（&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;）</strong>：可以直接使用，因为浮点数的有序性保证了大小关系的正确性。</p><p><strong>示例</strong>：<code>3.14 &gt; 2.71</code> 或 <code>a &lt; b</code> 的运算结果是可靠的。</p></li><li><p><strong>相等性比较（&#x3D;&#x3D;）的风险</strong>：</p></li></ul><p>​<strong>精度陷阱</strong>：浮点数的二进制存储可能导致微小误差，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>  <span class="comment">// 在多数语言中返回 False（实际值可能是 0.30000000000000004）</span></span><br></pre></td></tr></table></figure><p>​我们可以看到，两个浮点数由于存在精度问题，所以是无法直接判断是否相等的，那么这是为什么呢，又应该如何解决呢？</p><h3 id="2-浮点数出现精度问题的原因："><a href="#2-浮点数出现精度问题的原因：" class="headerlink" title="2. 浮点数出现精度问题的原因："></a>2. 浮点数出现精度问题的原因：</h3><p>浮点数（例如 <code>double</code> 类型）在计算机中是按照 IEEE 754 标准存储的。这种表示方式由三个部分组成：</p><ol><li><strong>符号位（Sign bit）</strong>：1 位，用于表示正负数。<code>0</code> 表示正数，<code>1</code> 表示负数。</li><li><strong>指数部分（Exponent）</strong>：用于表示数值的大小范围。对于 <code>double</code> 类型，占用 11 位。</li><li><strong>尾数部分（Mantissa or Fraction）</strong>：用于表示有效数字（精度部分），<code>double</code> 类型占用 52 位。</li></ol><p>由于十进制小数通过<strong>乘二取整</strong>法转换成二进制小数后往往是一个无限循环小数，但是计算机存储的尾数部分长度是有限的，所以就会对无限循环小数进行截断，我们在使用的时候，使用的是截断后的二进制数据转换成十进制后的数据 ，这样就导致了误差的产生。下面是具体的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义三个double类型的浮点数a, b, c</span></span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span>; <span class="comment">// 0.10000000149011611938476562</span></span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span>; <span class="comment">// 0.20000000298023223876953125</span></span><br><span class="line"><span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0.3</span>; <span class="comment">// 0.29999999999999998889776975</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接输出a，b，c的值</span></span><br><span class="line">System.out.println(a); <span class="comment">// 0.1</span></span><br><span class="line">System.out.println(b); <span class="comment">// 0.2</span></span><br><span class="line">System.out.println(c); <span class="comment">// 0.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接打印出来的值没有精度问题，但是如果我们使用这三个变量进行浮点数计算，就会发现出现了精度问题</span></span><br><span class="line">System.out.println(a + b); <span class="comment">// 0.30000000000000004</span></span><br><span class="line">System.out.println(a + b - c); <span class="comment">// 5.551115123125783E-17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以当我们使用浮点数直接和0比较大小，或者通过和0比较判断正负时，运行的结果和真实的结果有误差</span></span><br><span class="line">System.out.println((a + b - c) &gt; <span class="number">0</span>); <span class="comment">// 实际的结果为false，但是代码的输出确实true</span></span><br></pre></td></tr></table></figure><h3 id="3-浮点数精度问题的解决："><a href="#3-浮点数精度问题的解决：" class="headerlink" title="3. 浮点数精度问题的解决："></a>3. 浮点数精度问题的解决：</h3><p>想要解决浮点数的精度问题，首先要规定一个<strong>误差精度</strong>，当误差的值比这个精度小的话，就认为<strong>没有误差</strong>，误差的精度需要根据具体的业务进行设计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置精度</span></span><br><span class="line"><span class="type">double</span> <span class="variable">epsilon</span> <span class="operator">=</span> <span class="number">1e-16</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(epsilon); </span><br><span class="line">System.out.println(a + b - c); <span class="comment">// 5.551115123125783E-17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Math.abs(a + b - c) &lt; epsilon) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a + b - c 和 0 相等&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a + b - c 和 0 不相等&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行这段代码输出的结果为：a + b - c 和 0 相等，但是当我们把精度调成epsilon = 1e-17的时候，这个结果就会变成a + b - c 和 0 不相等，所以精度的选择是非常重要的，一定要保证业务中浮点数的计算结果不会超过这个精度</span></span><br></pre></td></tr></table></figure><p><strong>常见问题的解决方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设业务中的浮点数计算的误差精度不会超过1e-8，浮点数类型按double计算</span></span><br><span class="line"><span class="type">double</span> <span class="variable">epsilon</span> <span class="operator">=</span> <span class="number">1e-8</span>;</span><br><span class="line"><span class="comment">// 这个temp是业务中通过计算后得到的,这里就不指定具体数值了</span></span><br><span class="line"><span class="type">double</span> temp; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断浮点数是否等于0</span></span><br><span class="line"><span class="keyword">if</span> (Math.abs(temp) &lt; epsilon) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;浮点数：&quot;</span> + temp + <span class="string">&quot;和0相等&quot;</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断浮点数和0不相等</span></span><br><span class="line"><span class="keyword">if</span> (Math.abs(temp) &gt;= epsilon) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;浮点数：&quot;</span> + temp + <span class="string">&quot;和0不相等&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断浮点数大于0</span></span><br><span class="line"><span class="keyword">if</span> (temp &gt; epsilon) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;浮点数：&quot;</span> + temp + <span class="string">&quot;大于0&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断浮点数小于0</span></span><br><span class="line"><span class="keyword">if</span> (Math.abs(temp) &gt; epsilon &amp;&amp; temp &lt; epsilon) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;浮点数：&quot;</span> + temp + <span class="string">&quot;小于0&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个浮点数的大小关系，只需要让这两个浮点数做差，得到一个新的浮点数，然后再和0比较大小即可</span></span><br></pre></td></tr></table></figure><p><strong>可以直接比较大小的情况：</strong>如果是以下的两种情况，两个浮点数可以直接比较大小，精度误差不影响最终结果</p><ul><li>如果比较大小的两个浮点数都是直接定义的或者直接从数据库获取，并且都没有参数过浮点数运算</li><li>非常明确这两个浮点数不会存在相等的情况。</li></ul><h3 id="4-精度问题总结："><a href="#4-精度问题总结：" class="headerlink" title="4. 精度问题总结："></a>4. 精度问题总结：</h3><p>如果想要使用浮点数比较大小的话有两种简单的方法，一种方法是使用<code>round</code>函数，把浮点数的精度限定在一个规定的精度内，在这个精度内进行比较大小；一种方法是定义一个精度<code>epsilon</code>，通过让浮点数和<code>epsilon</code>进行比较来判断浮点数的正负或者两个浮点数的大小关系。</p></div>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
